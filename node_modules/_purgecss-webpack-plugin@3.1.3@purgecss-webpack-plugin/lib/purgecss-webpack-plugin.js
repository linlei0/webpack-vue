"use strict";var t=require("fs"),s=require("path"),e=require("purgecss"),o=require("webpack-sources");function i(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var n=i(s),r=i(e);const a=[".css",".scss",".styl",".sass",".less"];module.exports=class{constructor(t){this.purgedStats={},this.options=t}apply(t){t.hooks.compilation.tap("PurgeCSS",this.initializePlugin.bind(this))}initializePlugin(s){s.hooks.additionalAssets.tapPromise("PurgeCSS",(()=>{const e="function"==typeof this.options.paths?this.options.paths():this.options.paths;return e.forEach((s=>{if(!t.existsSync(s))throw new Error(`Path ${s} does not exist.`)})),this.runPluginHook(s,e)}))}async runPluginHook(t,s){const i=Object.entries(t.assets).filter((([t])=>function(t,s){const e=n.default.extname((o=t).includes("?")?o.split("?").slice(0,-1).join(""):o);var o;return s.includes(e)}(t,[".css"])));for(const n of t.chunks){const c=i.filter((([t])=>this.options.only?this.options.only.some((s=>t.includes(s))):Array.isArray(n.files)?n.files.includes(t):n.files.has(t)));for(const[i,n]of c){const c=s.filter((t=>!a.some((s=>t.endsWith(s))))),u={...e.defaultOptions,...this.options,content:c,css:[{raw:n.source().toString()}]};"function"==typeof u.safelist&&(u.safelist=u.safelist());const l=(await(new r.default).purge({content:u.content,css:u.css,defaultExtractor:u.defaultExtractor,extractors:u.extractors,fontFace:u.fontFace,keyframes:u.keyframes,output:u.output,rejected:u.rejected,variables:u.variables,safelist:u.safelist}))[0];l.rejected&&(this.purgedStats[i]=l.rejected),t.updateAsset(i,new o.ConcatSource(l.css))}}}};
