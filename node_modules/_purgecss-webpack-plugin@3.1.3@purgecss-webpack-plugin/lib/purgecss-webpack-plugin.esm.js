import{existsSync as s}from"fs";import t from"path";import e,{defaultOptions as o}from"purgecss";import{ConcatSource as i}from"webpack-sources";const n=[".css",".scss",".styl",".sass",".less"];export default class{constructor(s){this.purgedStats={},this.options=s}apply(s){s.hooks.compilation.tap("PurgeCSS",this.initializePlugin.bind(this))}initializePlugin(t){t.hooks.additionalAssets.tapPromise("PurgeCSS",(()=>{const e="function"==typeof this.options.paths?this.options.paths():this.options.paths;return e.forEach((t=>{if(!s(t))throw new Error(`Path ${t} does not exist.`)})),this.runPluginHook(t,e)}))}async runPluginHook(s,r){const a=Object.entries(s.assets).filter((([s])=>function(s,e){const o=t.extname((i=s).includes("?")?i.split("?").slice(0,-1).join(""):i);var i;return e.includes(o)}(s,[".css"])));for(const t of s.chunks){const c=a.filter((([s])=>this.options.only?this.options.only.some((t=>s.includes(t))):Array.isArray(t.files)?t.files.includes(s):t.files.has(s)));for(const[t,a]of c){const c=r.filter((s=>!n.some((t=>s.endsWith(t))))),l={...o,...this.options,content:c,css:[{raw:a.source().toString()}]};"function"==typeof l.safelist&&(l.safelist=l.safelist());const f=(await(new e).purge({content:l.content,css:l.css,defaultExtractor:l.defaultExtractor,extractors:l.extractors,fontFace:l.fontFace,keyframes:l.keyframes,output:l.output,rejected:l.rejected,variables:l.variables,safelist:l.safelist}))[0];f.rejected&&(this.purgedStats[t]=f.rejected),s.updateAsset(t,new i(f.css))}}}}
